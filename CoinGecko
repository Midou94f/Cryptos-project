# Importation des biblioth√®ques n√©cessaires
library(crayon)
library(dplyr)
library(jsonlite)     # Pour lire les donn√©es JSON
library(httr)         # Pour les appels API
library(kableExtra)

# D√©finition des styles existants
question_style <- blue$bold
info_style <- white$italic
warning_style <- red$bold
success_style <- green$bold
highlight_style <- yellow$bold
info_secondary_style <- cyan$italic
error_style <- red$bold$underline
section_title_style <- magenta$bold$underline


#############################
# Dataframe global pour stocker les donn√©es
coingecko_data <- NULL

# Fonction pour t√©l√©charger les donn√©es depuis CoinGecko
download_coingecko_data <- function() {
  url <- "https://api.coingecko.com/api/v3/coins/markets"
  params <- list(
    vs_currency = "usd",
    order = "market_cap_desc",
    per_page = 250,
    page = 1,
    sparkline = FALSE
  )
  
  response <- GET(url, query = params)
  
  if (status_code(response) == 200) {
    data <- fromJSON(content(response, "text", encoding = "UTF-8"))
    assign("coingecko_data", data, envir = .GlobalEnv)
    cat(success_style("\nDonn√©es t√©l√©charg√©es avec succ√®s depuis CoinGecko !\n"))
  } else {
    cat(error_style("\nErreur lors de la r√©cup√©ration des donn√©es depuis CoinGecko. V√©rifiez votre connexion ou les param√®tres API.\n"))
    assign("coingecko_data", NULL, envir = .GlobalEnv)
  }
}

####################################################
# Fonction corrig√©e pour afficher un tableau avec colonnes fixes et couleurs
display_table_fixed_colored <- function(data, title) {
  # Largeurs fixes pour chaque colonne
  col_widths <- c(40, 15, 10)  # Largeurs pour chaque colonne
  
  # Fonction pour tronquer ou remplir les colonnes
  format_column <- function(column, width) {
    sapply(column, function(x) {
      x <- substr(x, 1, width)  # Tronque les cha√Ænes trop longues
      sprintf(paste0("%-", width, "s"), x)  # Ajoute des espaces si n√©cessaire
    })
  }
  
  # Formater les en-t√™tes
  header <- sprintf(
    "%-*s | %-*s | %-*s",
    col_widths[1], "Nom",
    col_widths[2], "Symbole",
    col_widths[3], "Variation"
  )
  
  # Formater les donn√©es
  formatted_data <- data.frame(
    Nom = format_column(data$name, col_widths[1]),
    Symbole = format_column(data$symbol, col_widths[2]),
    Variation = format_column(data$price_change_percentage_24h, col_widths[3])
  )
  
  # Appliquer des couleurs aux donn√©es
  formatted_data$Nom <- cli::col_cyan(formatted_data$Nom)
  formatted_data$Symbole <- cli::col_yellow(formatted_data$Symbole)
  formatted_data$Variation <- ifelse(
    as.numeric(gsub("%", "", data$price_change_percentage_24h)) >= 0,
    cli::col_green(formatted_data$Variation),  # Vert pour positif
    cli::col_red(formatted_data$Variation)    # Rouge pour n√©gatif
  )
  
  # Afficher le titre
  cat(cli::col_magenta(title), "\n")
  
  # Afficher les en-t√™tes
  cat(header, "\n")
  
  # Ligne de s√©paration
  cat(paste0(rep("-", sum(col_widths) + 6), collapse = ""), "\n")
  
  # Afficher chaque ligne de donn√©es
  for (i in 1:nrow(formatted_data)) {
    cat(sprintf(
      "%-*s | %-*s | %-*s\n",
      col_widths[1], formatted_data$Nom[i],
      col_widths[2], formatted_data$Symbole[i],
      col_widths[3], formatted_data$Variation[i]
    ))
  }
}


##########################################################
# Fonction pour analyser les variations de prix
process_price_signals <- function(data) {
  cat(section_title_style("\n=== Signal Prix ===\n"))
  
  cat(info_style("\nDans cette section, vous trouverez les "))
  cat(highlight_style("d√©tails des variations de prix des cryptomonnaies sur les derni√®res 24 heures"))
  cat(info_style(", tri√©es selon diff√©rents crit√®res pour une analyse pr√©cise et rapide.\n\n"))
  
  cat(success_style("=== Organisation des donn√©es : ===\n"))
  cat(info_style("- Les cryptomonnaies ayant connu "))
  cat(success_style("les plus fortes progressions"))
  cat(info_style(" sur 24 heures sont list√©es par ordre d√©croissant.\n"))
  cat(info_style("- Les cryptomonnaies ayant enregistr√© "))
  cat(warning_style("les plus fortes baisses"))
  cat(info_style(" sont tri√©es par ordre croissant.\n"))
  cat(info_style("- Nous mettons √©galement en avant un classement des "))
  cat(highlight_style("10 meilleures performances"))
  cat(info_style(" et des "))
  cat(highlight_style("10 pires performances"))
  cat(info_style(", pour identifier rapidement les signaux les plus marquants.\n\n"))
  
  cat(success_style("=== Source des donn√©es : ===\n"))
  cat(info_style("Les donn√©es affich√©es ici proviennent de "))
  cat(highlight_style("l'API CoinGecko"))
  cat(info_style(", une r√©f√©rence mondiale en mati√®re d‚Äôinformations sur les cryptomonnaies. Elles sont collect√©es et mises √† jour r√©guli√®rement pour garantir leur fiabilit√©.\n\n"))
  
  cat(success_style("=== Pr√©sentation des r√©sultats : ===\n"))
  cat(info_style("Les donn√©es sont organis√©es sous forme de tableaux contenant les informations suivantes :\n"))
  cat(info_style("- "))
  cat(highlight_style("Nom de la cryptomonnaie"))
  cat(info_style(" : Identification de l‚Äôactif.\n"))
  cat(info_style("- "))
  cat(highlight_style("Symbole"))
  cat(info_style(" : Abr√©viation officielle (par exemple, BTC pour Bitcoin).\n"))
  cat(info_style("- "))
  cat(highlight_style("Variation de prix sur 24h"))
  cat(info_style(" : Exprim√©e en pourcentage, arrondie √† deux d√©cimales pour plus de clart√©.\n\n"))
  
  cat(success_style("=== Structure des r√©sultats affich√©s : ===\n"))
  cat(info_style("1. "))
  cat(highlight_style("Top 50 Progressions"))
  cat(info_style(" : Liste des cryptomonnaies ayant enregistr√© les plus fortes hausses de prix.\n"))
  cat(info_style("2. "))
  cat(highlight_style("Top 50 Baisse"))
  cat(info_style(" : Liste des cryptomonnaies ayant subi les plus fortes baisses.\n"))
  cat(info_style("3. "))
  cat(highlight_style("Signaux Haussiers (Top 10)"))
  cat(info_style(" : Les 10 actifs les plus performants.\n"))
  cat(info_style("4. "))
  cat(highlight_style("Signaux Baissiers (Top 10)"))
  cat(info_style(" : Les 10 actifs ayant connu les plus grandes baisses.\n\n"))
  
  cat(warning_style("Note : "))
  cat(info_style("Ces donn√©es fournissent une vue d‚Äôensemble claire des mouvements r√©cents sur les 24 derni√®res heures.\n\n"))
  
  ############
  
  if (is.null(data) || nrow(data) == 0) {
    cat(error_style("\nErreur : Les donn√©es ne sont pas disponibles. Veuillez v√©rifier l'appel API.\n"))
    return()
  }
  
  ################## 
  # Nettoyage et pr√©paration des donn√©es
  cleaned_data <- data %>%
    select(name, symbol, price_change_percentage_24h) %>%
    mutate(
      price_change_percentage_24h = paste0(round(as.numeric(price_change_percentage_24h), 2), "%")
    )
  
  # Top 50 Progressions
  display_table_fixed_colored(
    cleaned_data %>% arrange(desc(as.numeric(gsub("%", "", price_change_percentage_24h)))) %>% head(50),
    "Tableau des variations en % des derni√®res 24 heures : Top 50 Progressions "
  )
  cat(cli::col_green("\nCe tableau pr√©sente les cryptomonnaies ayant enregistr√© les meilleures progressions sur les derni√®res 24 heures.\n\n"))
  
  # Top 50 Baisses
  display_table_fixed_colored(
    cleaned_data %>% arrange(as.numeric(gsub("%", "", price_change_percentage_24h))) %>% head(50),
    "Tableau des variations en % des derni√®res 24 heures : Top 50 Baisses"
  )
  cat(cli::col_red("\nCe tableau pr√©sente les cryptomonnaies ayant subi les plus fortes baisses sur les derni√®res 24 heures.\n\n"))
  
  # Signaux Haussiers (Top 10)
  display_table_fixed_colored(
    cleaned_data %>% arrange(desc(as.numeric(gsub("%", "", price_change_percentage_24h)))) %>% head(10),
    "Tableau des Signaux Haussiers (Top 10)"
  )
  cat(cli::col_green("\nLes 10 cryptomonnaies les plus performantes √† surveiller.\n\n"))
  
  # Signaux Baissiers (Top 10)
  display_table_fixed_colored(
    cleaned_data %>% arrange(as.numeric(gsub("%", "", price_change_percentage_24h))) %>% head(10),
    "Tableau des Signaux Baissiers (Top 10)"
  )
  cat(cli::col_red("\nLes 10 cryptomonnaies ayant subi les plus fortes baisses.\n"))
  
}


###############################################################################
##### 3 VOLUME ET TRADING
###############################################################################

# Fonction pour formater les grands nombres avec des espaces
format_number <- function(number) {
  # Conversion en milliards
  number_in_billions <- number / 1000000000
  # Formatage avec 2 d√©cimales
  formatted <- sprintf("%.2f", number_in_billions)
  # Ajout des espaces pour les milliers
  parts <- strsplit(formatted, "\\.")[[1]]
  whole_part <- parts[1]
  decimal_part <- parts[2]
  whole_part <- format(as.numeric(whole_part), big.mark = " ", scientific = FALSE)
  return(paste0(whole_part, ".", decimal_part))
}

# Fonction modifi√©e pour afficher un tableau avec les nouvelles colonnes
display_volume_table <- function(data, title) {
  # Largeurs fixes pour chaque colonne
  col_widths <- c(40, 15, 15, 15, 10)  # Largeurs ajust√©es pour les nouvelles colonnes
  
  # Fonction pour tronquer ou remplir les colonnes
  format_column <- function(column, width) {
    sapply(column, function(x) {
      x <- substr(x, 1, width)  # Tronque les cha√Ænes trop longues
      sprintf(paste0("%-", width, "s"), x)  # Ajoute des espaces si n√©cessaire
    })
  }
  
  # Formater les en-t√™tes
  header <- sprintf(
    "%-*s | %-*s | %-*s | %-*s | %-*s",
    col_widths[1], "Nom",
    col_widths[2], "Symbole",
    col_widths[3], "Volume (B$)",
    col_widths[4], "MarketCap (B$)",
    col_widths[5], "Liquidit√© %"
  )
  
  # Formater les donn√©es
  formatted_data <- data.frame(
    Nom = format_column(data$name, col_widths[1]),
    Symbole = format_column(data$symbol, col_widths[2]),
    Volume = format_column(data$volume_formatted, col_widths[3]),
    MarketCap = format_column(data$market_cap_formatted, col_widths[4]),
    Liquidite = format_column(data$liquidity_percentage, col_widths[5])
  )
  
  # Appliquer des couleurs aux donn√©es
  formatted_data$Nom <- cli::col_cyan(formatted_data$Nom)
  formatted_data$Symbole <- cli::col_yellow(formatted_data$Symbole)
  formatted_data$Volume <- cli::col_green(formatted_data$Volume)
  formatted_data$MarketCap <- cli::col_blue(formatted_data$MarketCap)
  formatted_data$Liquidite <- cli::col_magenta(formatted_data$Liquidite)
  
  # Afficher le titre
  cat(cli::col_magenta(title), "\n")
  
  # Afficher les en-t√™tes
  cat(header, "\n")
  
  # Ligne de s√©paration
  cat(paste0(rep("-", sum(col_widths) + 10), collapse = ""), "\n")
  
  # Afficher chaque ligne de donn√©es
  for (i in 1:nrow(formatted_data)) {
    cat(sprintf(
      "%-*s | %-*s | %-*s | %-*s | %-*s\n",
      col_widths[1], formatted_data$Nom[i],
      col_widths[2], formatted_data$Symbole[i],
      col_widths[3], formatted_data$Volume[i],
      col_widths[4], formatted_data$MarketCap[i],
      col_widths[5], formatted_data$Liquidite[i]
    ))
  }
}

# Fonction principale pour analyser les volumes et la liquidit√©
process_volume_trading <- function(data) {
  cat(section_title_style("\n=== Analyse des Volumes et de la Liquidit√© ===\n"))
  
  cat(section_title_style("\nDans cette section, vous trouverez les analyses des volumes de trading et de la liquidit√©"))
  cat(" des cryptomonnaies, bas√©es sur les donn√©es de l'API CoinGecko.\n\n")
  
  cat("Nous vous pr√©senterons :\n")
  cat(info_style(" La relation entre les volumes √©chang√©s et la capitalisation boursi√®re sur 24h\n"))
  cat(info_style(" Les niveau de volumes de trading\n"))  
  cat(info_style(" Les indicateurs cl√©s de liquidit√©\n\n"))
  
  cat(highlight_style("La compr√©hension de ces √©l√©ments est essentielle"))
  cat(info_secondary_style(" pour interpr√©ter l'activit√© du march√©, √©valuer la facilit√© √† acheter ou vendre un actif "))
  cat("et d√©tecter de potentielles anomalies.\n\n")
  
  cat(success_style("Plongeons maintenant dans l'analyse de ces donn√©es de volumes et de liquidit√©."))
  
  if (is.null(data) || nrow(data) == 0) {
    cat(error_style("\nErreur : Les donn√©es ne sont pas disponibles. Veuillez v√©rifier l'appel API.\n"))
    return()
  }
  
  # Pr√©paration et nettoyage des donn√©es
  cleaned_data <- data %>%
    select(name, symbol, total_volume, market_cap) %>%
    mutate(
      # Conversion en milliards avec formatage am√©lior√©
      volume_formatted = sapply(total_volume, format_number),
      market_cap_formatted = sapply(market_cap, format_number),
      # Calcul du ratio de liquidit√© (volume/market_cap en pourcentage)
      liquidity_ratio = (total_volume / market_cap) * 100,
      liquidity_percentage = sprintf("%.2f%%", liquidity_ratio)
    )
  
  # Top 100 par volume
  cat(section_title_style("\n=== Top 100 Cryptomonnaies par Volume de Trading ===\n\n"))
  cat(highlight_style("Analyse des volumes de trading sur 24 heures (exprim√©s en milliards USD) des 100 cryptomonnaies les plus actives selon les donn√©es temps r√©el de CoinGecko. La capitalisation boursi√®re est √©galement exprim√©e en milliards USD pour une √©valuation comparative pr√©cise. Le volume d'√©changes est un indicateur cl√© de la profondeur du march√© et de l'int√©r√™t des traders.\n\n"))
  display_volume_table(
    cleaned_data %>% 
      arrange(desc(total_volume)) %>% 
      head(100),
    "Classement par Volume de Trading (Top 100)"
  )
  
  # Top 50 par liquidit√© (les plus √©lev√©s)
  cat(section_title_style("\n=== Top 50 Cryptomonnaies par Taux de Liquidit√© ===\n\n"))
  cat(highlight_style("Classement des 50 actifs pr√©sentant les meilleurs ratios de liquidit√© (Volume 24h / Market Cap). Ce ratio, exprim√© en pourcentage, est un indicateur crucial de la capacit√© d'un actif √† √™tre √©chang√© sans impact significatif sur son prix. Les volumes et capitalisations sont exprim√©s en milliards USD, donn√©es valid√©es par CoinGecko.\n\n"))
  display_volume_table(
    cleaned_data %>% 
      arrange(desc(liquidity_ratio)) %>% 
      head(50),
    "Classement par Taux de Liquidit√© le Plus √âlev√© (Top 50)"
  )
  
  # Top 50 par liquidit√© (les plus faibles)
  cat(section_title_style("\n=== Top 50 Cryptomonnaies avec le Taux de Liquidit√© le Plus Faible ===\n\n"))
  cat(highlight_style("Identification des 50 actifs pr√©sentant les ratios de liquidit√© (Volume 24h / Market Cap) les plus faibles parmi les principales cryptomonnaies. Un faible ratio peut indiquer une concentration importante des d√©tenteurs ou une faible activit√© de trading. Volumes et capitalisations exprim√©s en milliards USD. Donn√©es fournies en temps r√©el par l'API CoinGecko.\n\n"))
  display_volume_table(
    cleaned_data %>% 
      arrange(liquidity_ratio) %>% 
      head(50),
    "Classement par Taux de Liquidit√© le Plus Faible (Top 50)"
  )
}

###############################################################################
####. Statistiques sociales
###############################################################################

# Fonction pour formater les grands nombres
format_large_number <- function(x) {
  format(x, big.mark = " ", scientific = FALSE)
}

# Fonction pour le formatage des tableaux
display_table_fixed_colored2 <- function(data) {
  # Largeurs fixes pour chaque type de colonne
  col_widths <- c(
    name = 30,
    symbol = 10,
    id = 25,
    market_cap = 20,
    twitter_followers = 20,
    sentiment_votes_up = 20,
    sentiment_votes_down = 20
  )
  
  # Fonction pour formater une colonne
  format_column <- function(values, width) {
    sapply(values, function(x) {
      x <- substr(as.character(x), 1, width)
      sprintf(paste0("%-", width, "s"), x)
    })
  }
  
  # Formater l'en-t√™te
  header_parts <- mapply(function(name, width) {
    sprintf(paste0("%-", width, "s"), toupper(name))
  }, names(data), col_widths[names(data)])
  
  header <- paste(header_parts, collapse = " | ")
  
  # Afficher l'en-t√™te
  cat(cli::col_yellow(header), "\n")
  cat(paste(rep("-", sum(col_widths[names(data)]) + (3 * (ncol(data) - 1))), collapse = ""), "\n")
  
  # Formater et afficher chaque ligne avec des couleurs
  for(i in 1:nrow(data)) {
    row_values <- mapply(function(value, col_name, width) {
      formatted <- format_column(value, width)
      switch(col_name,
             "name" = cli::col_cyan(formatted),
             "symbol" = cli::col_green(formatted),
             "id" = cli::col_magenta(formatted),
             "market_cap" = cli::col_yellow(formatted),
             "twitter_followers" = cli::col_blue(formatted),
             "sentiment_votes_up" = cli::col_green(formatted),
             "sentiment_votes_down" = cli::col_red(formatted),
             formatted)
    }, as.list(data[i,]), names(data), col_widths[names(data)])
    
    cat(paste(row_values, collapse = " | "), "\n")
  }
  cat("\n")
}

# Fonction pour t√©l√©charger les 250 premi√®res cryptos
get_top_cryptos <- function() {
  url <- "https://api.coingecko.com/api/v3/coins/markets"
  params <- list(
    vs_currency = "usd",
    order = "market_cap_desc",
    per_page = 250,
    page = 1,
    sparkline = FALSE
  )
  
  response <- GET(url, query = params)
  
  if (status_code(response) == 200) {
    data <- fromJSON(content(response, "text", encoding = "UTF-8"))
    cat(success_style("\nDonn√©es des 250 premi√®res cryptos t√©l√©charg√©es avec succ√®s !\n\n"))
    return(data)
  } else {
    cat(error_style("\nErreur lors de la r√©cup√©ration des donn√©es.\n"))
    return(NULL)
  }
}

# Fonction pour t√©l√©charger les donn√©es sociales
get_social_data <- function(id) {
  url <- paste0("https://api.coingecko.com/api/v3/coins/", id)
  response <- GET(url)
  
  if (status_code(response) == 200) {
    data <- fromJSON(content(response, "text", encoding = "UTF-8"))
    return(data)
  } else if (status_code(response) == 429) {
    cat(warning_style("\nLimite atteinte pour ", id, ". Pause de 61 secondes...\n"))
    Sys.sleep(61)
    return(NULL)
  } else {
    cat(error_style(paste0("\nErreur lors de la r√©cup√©ration des donn√©es pour ", id, "\n")))
    return(NULL)
  }
}

# Menu principal
social_main_menu <- function() {
  repeat {
    cat(section_title_style("\n Options - Social Metrics des Cryptos\n\n"))
    cat(question_style("0) Revenir au menu pr√©c√©dent\n"))
    cat("1) Visualiser les socials metrics sociales d'une crypto sp√©cifique\n")
    cat("2) Visualiser les socials metrics du march√© crypto en g√©n√©ral\n")
    
    # Lecture et validation de l'entr√©e utilisateur
    repeat {
      choix <- suppressWarnings(as.integer(readline(question_style("\nVeuillez entrer votre choix (0, 1 ou 2) : "))))
      
      # V√©rification si choix est NA ou hors limites
      if (!is.na(choix) && choix >= 0 && choix <= 2) {
        break
      }
      cat(warning_style("\nChoix invalide. Veuillez entrer 0, 1 ou 2 uniquement.\n"))
    }
    
    if (choix == 0) {
      cat(info_style("\nRetour au menu pr√©c√©dent...\n"))
      break
    } else if (choix == 1) {
      visualiser_crypto_specifique()
    } else if (choix == 2) {
      visualiser_cryptos_generales()
    }
  }
}

# Visualisation d'une crypto sp√©cifique
visualiser_crypto_specifique <- function() {
  cat(section_title_style("\nVisualisation des socials metrics d'une crypto sp√©cifique\n"))
  
  repeat {
    connait_id <- tolower(readline(question_style("Connaissez-vous l'ID de la crypto ? (oui/non) : ")))
    if (connait_id %in% c("oui", "non")) break
    cat(warning_style("\nVeuillez r√©pondre uniquement par 'oui' ou 'non'.\n"))
  }
  
  if (connait_id == "oui") {
    repeat {
      id <- readline(question_style("Veuillez entrer l'ID de la crypto : "))
      social_data <- get_social_data(id)
      
      if (!is.null(social_data)) {
        cat(success_style("\nDonn√©es pour ", id, " t√©l√©charg√©es avec succ√®s !\n\n"))
        
        # Cr√©ation d'un tableau format√©
        result_df <- data.frame(
          name = social_data$name,
          symbol = social_data$symbol,
          twitter_followers = format_large_number(social_data$community_data$twitter_followers),
          sentiment_votes_up = paste0(round(social_data$sentiment_votes_up_percentage, 2), "%"),
          sentiment_votes_down = paste0(round(social_data$sentiment_votes_down_percentage, 2), "%"),
          stringsAsFactors = FALSE
        )
        
        display_table_fixed_colored2(result_df)
        
        # Analyse du sentiment
        mood_global <- social_data$sentiment_votes_up_percentage
        cat(section_title_style("Analyse du Sentiment :\n\n"))
        cat("Mood Global : ", highlight_style(paste0(round(mood_global, 2), "%\n\n")))
        
        sentiment_message <- if (mood_global > 70) {
          success_style("Le sentiment est hyper positif - Bull Market en vue ! üöÄ")
        } else if (mood_global > 50) {
          success_style("Le sentiment est globalement positif üìà")
        } else if (mood_global > 30) {
          warning_style("Le sentiment est globalement n√©gatif üìâ")
        } else {
          error_style("Le sentiment est hyper n√©gatif - Bear Market en vue ! üêª")
        }
        
        cat(sentiment_message, "\n\n")
        break
      } else {
        cat(warning_style("\nID invalide ou probl√®me lors de la r√©cup√©ration. Veuillez r√©essayer.\n"))
      }
    }
  } else {
    top_cryptos <- get_top_cryptos()
    if (!is.null(top_cryptos)) {
      display_df <- top_cryptos %>% 
        select(name, id, market_cap) %>%
        head(250) %>%
        mutate(market_cap = paste0(format_large_number(round(market_cap / 1e9, 2)), " Mds $"))
      
      cat(section_title_style("\nListe des 250 plus grandes cryptos :\n\n"))
      display_table_fixed_colored2(display_df)
      readline(info_style("Veuillez noter l'ID qui vous int√©resse et appuyer sur Entr√©e pour continuer...\n"))
      visualiser_crypto_specifique()
    }
  }
}

# Visualisation des cryptos en g√©n√©ral
visualiser_cryptos_generales <- function() {
  repeat {
    cat(section_title_style("\nVisualisation des sociales metrics des cryptos\n\n"))
    cat(question_style("0) Retour au menu principal\n"))
    cat("1) Visualiser les 4 plus grandes cryptos (", warning_style("Temps d'attente: < 60 secondes"), ")\n")
    cat("2) Visualiser les 8 plus grandes cryptos (", warning_style("temps d'attente estim√© : 2 minutes"), ")\n")
    cat("3) Visualiser les 12 plus grandes cryptos (", warning_style("temps d'attente estim√© : 3 minutes"), ")\n")
    cat("4) Visualiser les 16 plus grandes cryptos (", warning_style("temps d'attente estim√© : 4 minutes"), ")\n")
    cat("5) Choisir un nombre personnalis√© de cryptos (", warning_style("Maximum 50"), ")\n")
    
    # Lecture et validation de l'entr√©e utilisateur
    repeat {
      choix <- suppressWarnings(as.integer(readline(question_style("\nVeuillez entrer votre choix (0-5) : "))))
      
      # V√©rification si choix est NA ou hors limites
      if (!is.na(choix) && choix >= 0 && choix <= 5) {
        break
      }
      cat(warning_style("\nChoix invalide. Veuillez entrer un nombre entre 0 et 5.\n"))
    }
    
    if (choix == 0) {
      cat(info_style("\nRetour au menu principal...\n"))
      break
    } else if (choix == 5) {
      # Gestion du nombre personnalis√©
      repeat {
        nombre_perso <- suppressWarnings(as.integer(readline(question_style("\nEntrez le nombre de cryptos √† visualiser (maximum 50) : "))))
        
        if (!is.na(nombre_perso) && nombre_perso > 0 && nombre_perso <= 50) {
          temps_estime <- ceiling(nombre_perso / 4) * 1.5
          cat(warning_style(paste0("\nTemps d'attente estim√© : ", temps_estime, " minutes\n")))
          
          repeat {
            choix_confirme <- tolower(readline(question_style("Voulez-vous continuer ? (oui/non) : ")))
            if (choix_confirme %in% c("oui", "non")) break
            cat(warning_style("\nVeuillez r√©pondre uniquement par 'oui' ou 'non'.\n"))
          }
          
          if (choix_confirme == "oui") {
            top_cryptos <- get_top_cryptos()
            if (!is.null(top_cryptos)) {
              top_ids <- head(top_cryptos$id, nombre_perso)
              afficher_social_metrics(top_ids)
            }
          }
          break
        } else {
          cat(warning_style("\nNombre invalide. Veuillez entrer un nombre entre 1 et 50.\n"))
        }
      }
    } else if (choix >= 1 && choix <= 4) {
      nombre_cryptos <- choix * 4
      top_cryptos <- get_top_cryptos()
      if (!is.null(top_cryptos)) {
        top_ids <- head(top_cryptos$id, nombre_cryptos)
        afficher_social_metrics(top_ids)
      }
    }
  }
}

# Affichage des metrics sociales
afficher_social_metrics <- function(ids) {
  social_data_list <- list()
  sentiment_votes_raw <- numeric()  # Pour stocker les valeurs brutes des sentiments
  
  for (i in seq_along(ids)) {
    id <- ids[i]
    cat(info_style(paste0("\nT√©l√©chargement des donn√©es pour : ", id, "...\n")))
    
    social_data <- get_social_data(id)
    
    if (!is.null(social_data)) {
      sentiment_votes_raw <- c(sentiment_votes_raw, social_data$sentiment_votes_up_percentage)
      
      social_data_list[[i]] <- data.frame(
        name = social_data$name,
        symbol = social_data$symbol,
        twitter_followers = format_large_number(social_data$community_data$twitter_followers),
        sentiment_votes_up = paste0(round(social_data$sentiment_votes_up_percentage, 2), "%"),
        sentiment_votes_down = paste0(round(social_data$sentiment_votes_down_percentage, 2), "%"),
        stringsAsFactors = FALSE
      )
    }
    
    if (i %% 4 == 0 && i < length(ids)) {
      cat(warning_style("\nPause de 61 secondes pour respecter les limites de l'API...\n"))
      Sys.sleep(61)
    } else {
      Sys.sleep(2)
    }
  }
  
  cat("\nR√©sultats :\n\n")
  social_data_table <- do.call(rbind, social_data_list)
  display_table_fixed_colored2(social_data_table)
  
  # Calcul et affichage du sentiment global
  mood_global <- mean(sentiment_votes_raw)
  cat(section_title_style("Analyse du Sentiment Global :\n\n"))
  cat("Mood Global : ", highlight_style(paste0(round(mood_global, 2), "%\n\n")))
  
  # Analyse du sentiment
  sentiment_message <- if (mood_global > 70) {
    success_style("Le sentiment est hyper positif - Bull Market en vue ! üöÄ")
  } else if (mood_global > 50) {
    success_style("Le sentiment est globalement positif üìà")
  } else if (mood_global > 30) {
    warning_style("Le sentiment est globalement n√©gatif üìâ")
  } else {
    error_style("Le sentiment est hyper n√©gatif - Bear Market en vue ! üêª")
  }
  
  cat(sentiment_message, "\n\n")
}

# Ex√©cution du menu principal



################################################################################
# Fonction principale pour g√©rer le menu
################################################################################

coingecko <- function() {
  cat(section_title_style("\n D√©tection des p√©pites via CoinGecko - outils d'analyse !\n"))
  cat(success_style("\n===========================================================\n"))
  cat(highlight_style("\nExplorez les signaux prix, volumes, niches et tendances des cryptomonnaies!\n"))
  cat(success_style("===========================================================\n"))
  
  # T√©l√©charger les donn√©es une fois au d√©but
  download_coingecko_data()
  
  # V√©rifier si les donn√©es ont √©t√© correctement t√©l√©charg√©es
  if (is.null(coingecko_data) || nrow(coingecko_data) == 0) {
    cat(error_style("\nImpossible de continuer : les donn√©es n'ont pas √©t√© t√©l√©charg√©es correctement.\n"))
    return()
  }
  
  repeat {
    cat(section_title_style("\n=== Menu CoinGecko ===\n"))
    options <- c(
      "Revenir au menu P√©pitesHunter",
      "Signal Prix",
      "Volume et Trading",
      "Statistiques Sociales",
      "Analyse des Tendances et Recherches Populaires",
      "Donn√©es sur les Exchanges",
      "Tokens R√©cemment Ajout√©s"
    )
    
    for (i in seq_along(options)) {
      cat(paste0(i, ". ", options[i], "\n"))
    }
    
    choix <- readline(question_style("Veuillez choisir une option (par num√©ro) : "))
    
    # Dans la fonction coingecko(), modifie la partie du choix de menu :
    if (choix == "1") {
      cat(info_style("\nRetour au menu P√©pitesHunter...\n"))
      break
    } else if (choix == "2") {
      process_price_signals(coingecko_data)
    } else if (choix == "3") {
      process_volume_trading(coingecko_data)
    } else if (choix == "4") {
      social_main_menu()
    } else if (choix %in% c("5", "6", "7")) {
      cat(warning_style("\nCette fonctionnalit√© est en cours de d√©veloppement. Elle sera bient√¥t disponible !\n"))
    } else {
      cat(warning_style("\nChoix invalide. Veuillez r√©essayer.\n"))
    }
  }
}

# Appel √† la fonction principale
coingecko()

