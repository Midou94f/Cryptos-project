############### Pépites Hunter ###################
##############################################

# Chargement des bibliothèques nécessaires
library(crayon)  # Pour les styles de couleur
library(dplyr)   # Pour la manipulation des données
library(ggplot2) # Pour les visualisations (si nécessaire)
library(httr)    # Pour les appels API
library(jsonlite) # Pour travailler avec les données JSON
library(curl)
library(kableExtra)
library(cli)
library(scales)  # Pour le formatage des nombres

# Définition des styles
question_style <- blue$bold
info_style <- white$italic
warning_style <- red$bold
success_style <- green$bold
highlight_style <- yellow$bold
info_secondary_style <- cyan$italic
error_style <- red$bold$underline
section_title_style <- magenta$bold$underline
pro_style <- red$bold  # Style pour PRO


################################################################################
############## Signal prix 
#################################################################################

#############################
# Dataframe global pour stocker les données
coingecko_data <- NULL

# Fonction pour télécharger les données depuis CoinGecko
download_coingecko_data <- function() {
  url <- "https://api.coingecko.com/api/v3/coins/markets"
  params <- list(
    vs_currency = "usd",
    order = "market_cap_desc",
    per_page = 250,
    page = 1,
    sparkline = FALSE
  )
  
  response <- GET(url, query = params)
  
  if (status_code(response) == 200) {
    data <- fromJSON(content(response, "text", encoding = "UTF-8"))
    assign("coingecko_data", data, envir = .GlobalEnv)
    cat(success_style("\nDonnées téléchargées avec succès depuis CoinGecko !\n"))
  } else {
    cat(error_style("\nErreur lors de la récupération des données depuis CoinGecko. Vérifiez votre connexion ou les paramètres API.\n"))
    assign("coingecko_data", NULL, envir = .GlobalEnv)
  }
}

####################################################
# Fonction corrigée pour afficher un tableau avec colonnes fixes et couleurs
display_table_fixed_colored <- function(data, title) {
  # Largeurs fixes pour chaque colonne
  col_widths <- c(40, 15, 10)  # Largeurs pour chaque colonne
  
  # Fonction pour tronquer ou remplir les colonnes
  format_column <- function(column, width) {
    sapply(column, function(x) {
      x <- substr(x, 1, width)  # Tronque les chaînes trop longues
      sprintf(paste0("%-", width, "s"), x)  # Ajoute des espaces si nécessaire
    })
  }
  
  # Formater les en-têtes
  header <- sprintf(
    "%-*s | %-*s | %-*s",
    col_widths[1], "Nom",
    col_widths[2], "Symbole",
    col_widths[3], "Variation"
  )
  
  # Formater les données
  formatted_data <- data.frame(
    Nom = format_column(data$name, col_widths[1]),
    Symbole = format_column(data$symbol, col_widths[2]),
    Variation = format_column(data$price_change_percentage_24h, col_widths[3])
  )
  
  # Appliquer des couleurs aux données
  formatted_data$Nom <- cli::col_cyan(formatted_data$Nom)
  formatted_data$Symbole <- cli::col_yellow(formatted_data$Symbole)
  formatted_data$Variation <- ifelse(
    as.numeric(gsub("%", "", data$price_change_percentage_24h)) >= 0,
    cli::col_green(formatted_data$Variation),  # Vert pour positif
    cli::col_red(formatted_data$Variation)    # Rouge pour négatif
  )
  
  # Afficher le titre
  cat(cli::col_magenta(title), "\n")
  
  # Afficher les en-têtes
  cat(header, "\n")
  
  # Ligne de séparation
  cat(paste0(rep("-", sum(col_widths) + 6), collapse = ""), "\n")
  
  # Afficher chaque ligne de données
  for (i in 1:nrow(formatted_data)) {
    cat(sprintf(
      "%-*s | %-*s | %-*s\n",
      col_widths[1], formatted_data$Nom[i],
      col_widths[2], formatted_data$Symbole[i],
      col_widths[3], formatted_data$Variation[i]
    ))
  }
}


##########################################################
# Fonction pour analyser les variations de prix
process_price_signals <- function(data) {
  cat(section_title_style("\n=== Signal Prix ===\n"))
  
  cat(info_style("\nDans cette section, vous trouverez les "))
  cat(highlight_style("détails des variations de prix des cryptomonnaies sur les dernières 24 heures"))
  cat(info_style(", triées selon différents critères pour une analyse précise et rapide.\n\n"))
  
  cat(success_style("=== Organisation des données : ===\n"))
  cat(info_style("- Les cryptomonnaies ayant connu "))
  cat(success_style("les plus fortes progressions"))
  cat(info_style(" sur 24 heures sont listées par ordre décroissant.\n"))
  cat(info_style("- Les cryptomonnaies ayant enregistré "))
  cat(warning_style("les plus fortes baisses"))
  cat(info_style(" sont triées par ordre croissant.\n"))
  cat(info_style("- Nous mettons également en avant un classement des "))
  cat(highlight_style("10 meilleures performances"))
  cat(info_style(" et des "))
  cat(highlight_style("10 pires performances"))
  cat(info_style(", pour identifier rapidement les signaux les plus marquants.\n\n"))
  
  cat(success_style("=== Source des données : ===\n"))
  cat(info_style("Les données affichées ici proviennent de "))
  cat(highlight_style("l'API CoinGecko"))
  cat(info_style(", une référence mondiale en matière d’informations sur les cryptomonnaies. Elles sont collectées et mises à jour régulièrement pour garantir leur fiabilité.\n\n"))
  
  cat(success_style("=== Présentation des résultats : ===\n"))
  cat(info_style("Les données sont organisées sous forme de tableaux contenant les informations suivantes :\n"))
  cat(info_style("- "))
  cat(highlight_style("Nom de la cryptomonnaie"))
  cat(info_style(" : Identification de l’actif.\n"))
  cat(info_style("- "))
  cat(highlight_style("Symbole"))
  cat(info_style(" : Abréviation officielle (par exemple, BTC pour Bitcoin).\n"))
  cat(info_style("- "))
  cat(highlight_style("Variation de prix sur 24h"))
  cat(info_style(" : Exprimée en pourcentage, arrondie à deux décimales pour plus de clarté.\n\n"))
  
  cat(success_style("=== Structure des résultats affichés : ===\n"))
  cat(info_style("1. "))
  cat(highlight_style("Top 50 Progressions"))
  cat(info_style(" : Liste des cryptomonnaies ayant enregistré les plus fortes hausses de prix.\n"))
  cat(info_style("2. "))
  cat(highlight_style("Top 50 Baisse"))
  cat(info_style(" : Liste des cryptomonnaies ayant subi les plus fortes baisses.\n"))
  cat(info_style("3. "))
  cat(highlight_style("Signaux Haussiers (Top 10)"))
  cat(info_style(" : Les 10 actifs les plus performants.\n"))
  cat(info_style("4. "))
  cat(highlight_style("Signaux Baissiers (Top 10)"))
  cat(info_style(" : Les 10 actifs ayant connu les plus grandes baisses.\n\n"))
  
  cat(warning_style("Note : "))
  cat(info_style("Ces données fournissent une vue d’ensemble claire des mouvements récents sur les 24 dernières heures.\n\n"))
  
  ############
  
  if (is.null(data) || nrow(data) == 0) {
    cat(error_style("\nErreur : Les données ne sont pas disponibles. Veuillez vérifier l'appel API.\n"))
    return()
  }
  
  ################## 
  # Nettoyage et préparation des données
  cleaned_data <- data %>%
    select(name, symbol, price_change_percentage_24h) %>%
    mutate(
      price_change_percentage_24h = paste0(round(as.numeric(price_change_percentage_24h), 2), "%")
    )
  
  # Top 50 Progressions
  display_table_fixed_colored(
    cleaned_data %>% arrange(desc(as.numeric(gsub("%", "", price_change_percentage_24h)))) %>% head(50),
    "Tableau des variations en % des dernières 24 heures : Top 50 Progressions "
  )
  cat(cli::col_green("\nCe tableau présente les cryptomonnaies ayant enregistré les meilleures progressions sur les dernières 24 heures.\n\n"))
  
  # Top 50 Baisses
  display_table_fixed_colored(
    cleaned_data %>% arrange(as.numeric(gsub("%", "", price_change_percentage_24h))) %>% head(50),
    "Tableau des variations en % des dernières 24 heures : Top 50 Baisses"
  )
  cat(cli::col_red("\nCe tableau présente les cryptomonnaies ayant subi les plus fortes baisses sur les dernières 24 heures.\n\n"))
  
  # Signaux Haussiers (Top 10)
  display_table_fixed_colored(
    cleaned_data %>% arrange(desc(as.numeric(gsub("%", "", price_change_percentage_24h)))) %>% head(10),
    "Tableau des Signaux Haussiers (Top 10)"
  )
  cat(cli::col_green("\nLes 10 cryptomonnaies les plus performantes à surveiller.\n\n"))
  
  # Signaux Baissiers (Top 10)
  display_table_fixed_colored(
    cleaned_data %>% arrange(as.numeric(gsub("%", "", price_change_percentage_24h))) %>% head(10),
    "Tableau des Signaux Baissiers (Top 10)"
  )
  cat(cli::col_red("\nLes 10 cryptomonnaies ayant subi les plus fortes baisses.\n"))
  
}


###############################################################################
##### 3 VOLUME ET TRADING
###############################################################################

# Fonction pour formater les grands nombres avec des espaces
format_number <- function(number) {
  # Conversion en milliards
  number_in_billions <- number / 1000000000
  # Formatage avec 2 décimales
  formatted <- sprintf("%.2f", number_in_billions)
  # Ajout des espaces pour les milliers
  parts <- strsplit(formatted, "\\.")[[1]]
  whole_part <- parts[1]
  decimal_part <- parts[2]
  whole_part <- format(as.numeric(whole_part), big.mark = " ", scientific = FALSE)
  return(paste0(whole_part, ".", decimal_part))
}

# Fonction modifiée pour afficher un tableau avec les nouvelles colonnes
display_volume_table <- function(data, title) {
  # Largeurs fixes pour chaque colonne
  col_widths <- c(40, 15, 15, 15, 10)  # Largeurs ajustées pour les nouvelles colonnes
  
  # Fonction pour tronquer ou remplir les colonnes
  format_column <- function(column, width) {
    sapply(column, function(x) {
      x <- substr(x, 1, width)  # Tronque les chaînes trop longues
      sprintf(paste0("%-", width, "s"), x)  # Ajoute des espaces si nécessaire
    })
  }
  
  # Formater les en-têtes
  header <- sprintf(
    "%-*s | %-*s | %-*s | %-*s | %-*s",
    col_widths[1], "Nom",
    col_widths[2], "Symbole",
    col_widths[3], "Volume (B$)",
    col_widths[4], "MarketCap (B$)",
    col_widths[5], "Liquidité %"
  )
  
  # Formater les données
  formatted_data <- data.frame(
    Nom = format_column(data$name, col_widths[1]),
    Symbole = format_column(data$symbol, col_widths[2]),
    Volume = format_column(data$volume_formatted, col_widths[3]),
    MarketCap = format_column(data$market_cap_formatted, col_widths[4]),
    Liquidite = format_column(data$liquidity_percentage, col_widths[5])
  )
  
  # Appliquer des couleurs aux données
  formatted_data$Nom <- cli::col_cyan(formatted_data$Nom)
  formatted_data$Symbole <- cli::col_yellow(formatted_data$Symbole)
  formatted_data$Volume <- cli::col_green(formatted_data$Volume)
  formatted_data$MarketCap <- cli::col_blue(formatted_data$MarketCap)
  formatted_data$Liquidite <- cli::col_magenta(formatted_data$Liquidite)
  
  # Afficher le titre
  cat(cli::col_magenta(title), "\n")
  
  # Afficher les en-têtes
  cat(header, "\n")
  
  # Ligne de séparation
  cat(paste0(rep("-", sum(col_widths) + 10), collapse = ""), "\n")
  
  # Afficher chaque ligne de données
  for (i in 1:nrow(formatted_data)) {
    cat(sprintf(
      "%-*s | %-*s | %-*s | %-*s | %-*s\n",
      col_widths[1], formatted_data$Nom[i],
      col_widths[2], formatted_data$Symbole[i],
      col_widths[3], formatted_data$Volume[i],
      col_widths[4], formatted_data$MarketCap[i],
      col_widths[5], formatted_data$Liquidite[i]
    ))
  }
}

# Fonction principale pour analyser les volumes et la liquidité
process_volume_trading <- function(data) {
  cat(section_title_style("\n=== Analyse des Volumes et de la Liquidité ===\n"))
  
  cat(section_title_style("\nDans cette section, vous trouverez les analyses des volumes de trading et de la liquidité"))
  cat(" des cryptomonnaies, basées sur les données de l'API CoinGecko.\n\n")
  
  cat("Nous vous présenterons :\n")
  cat(info_style(" La relation entre les volumes échangés et la capitalisation boursière sur 24h\n"))
  cat(info_style(" Les niveau de volumes de trading\n"))  
  cat(info_style(" Les indicateurs clés de liquidité\n\n"))
  
  cat(highlight_style("La compréhension de ces éléments est essentielle"))
  cat(info_secondary_style(" pour interpréter l'activité du marché, évaluer la facilité à acheter ou vendre un actif "))
  cat("et détecter de potentielles anomalies.\n\n")
  
  cat(success_style("Plongeons maintenant dans l'analyse de ces données de volumes et de liquidité."))
  
  if (is.null(data) || nrow(data) == 0) {
    cat(error_style("\nErreur : Les données ne sont pas disponibles. Veuillez vérifier l'appel API.\n"))
    return()
  }
  
  # Préparation et nettoyage des données
  cleaned_data <- data %>%
    select(name, symbol, total_volume, market_cap) %>%
    mutate(
      # Conversion en milliards avec formatage amélioré
      volume_formatted = sapply(total_volume, format_number),
      market_cap_formatted = sapply(market_cap, format_number),
      # Calcul du ratio de liquidité (volume/market_cap en pourcentage)
      liquidity_ratio = (total_volume / market_cap) * 100,
      liquidity_percentage = sprintf("%.2f%%", liquidity_ratio)
    )
  
  # Top 100 par volume
  cat(section_title_style("\n=== Top 100 Cryptomonnaies par Volume de Trading ===\n\n"))
  cat(highlight_style("Analyse des volumes de trading sur 24 heures (exprimés en milliards USD) des 100 cryptomonnaies les plus actives selon les données temps réel de CoinGecko. La capitalisation boursière est également exprimée en milliards USD pour une évaluation comparative précise. Le volume d'échanges est un indicateur clé de la profondeur du marché et de l'intérêt des traders.\n\n"))
  display_volume_table(
    cleaned_data %>% 
      arrange(desc(total_volume)) %>% 
      head(100),
    "Classement par Volume de Trading (Top 100)"
  )
  
  # Top 50 par liquidité (les plus élevés)
  cat(section_title_style("\n=== Top 50 Cryptomonnaies par Taux de Liquidité ===\n\n"))
  cat(highlight_style("Classement des 50 actifs présentant les meilleurs ratios de liquidité (Volume 24h / Market Cap). Ce ratio, exprimé en pourcentage, est un indicateur crucial de la capacité d'un actif à être échangé sans impact significatif sur son prix. Les volumes et capitalisations sont exprimés en milliards USD, données validées par CoinGecko.\n\n"))
  display_volume_table(
    cleaned_data %>% 
      arrange(desc(liquidity_ratio)) %>% 
      head(50),
    "Classement par Taux de Liquidité le Plus Élevé (Top 50)"
  )
  
  # Top 50 par liquidité (les plus faibles)
  cat(section_title_style("\n=== Top 50 Cryptomonnaies avec le Taux de Liquidité le Plus Faible ===\n\n"))
  cat(highlight_style("Identification des 50 actifs présentant les ratios de liquidité (Volume 24h / Market Cap) les plus faibles parmi les principales cryptomonnaies. Un faible ratio peut indiquer une concentration importante des détenteurs ou une faible activité de trading. Volumes et capitalisations exprimés en milliards USD. Données fournies en temps réel par l'API CoinGecko.\n\n"))
  display_volume_table(
    cleaned_data %>% 
      arrange(liquidity_ratio) %>% 
      head(50),
    "Classement par Taux de Liquidité le Plus Faible (Top 50)"
  )
}

###############################################################################
####. Statistiques sociales
###############################################################################

# Fonction pour formater les grands nombres
format_large_number <- function(x) {
  format(x, big.mark = " ", scientific = FALSE)
}

# Fonction pour le formatage des tableaux
display_table_fixed_colored2 <- function(data) {
  # Largeurs fixes pour chaque type de colonne
  col_widths <- c(
    name = 30,
    symbol = 10,
    id = 25,
    market_cap = 20,
    twitter_followers = 20,
    sentiment_votes_up = 20,
    sentiment_votes_down = 20
  )
  
  # Fonction pour formater une colonne
  format_column <- function(values, width) {
    sapply(values, function(x) {
      x <- substr(as.character(x), 1, width)
      sprintf(paste0("%-", width, "s"), x)
    })
  }
  
  # Formater l'en-tête
  header_parts <- mapply(function(name, width) {
    sprintf(paste0("%-", width, "s"), toupper(name))
  }, names(data), col_widths[names(data)])
  
  header <- paste(header_parts, collapse = " | ")
  
  # Afficher l'en-tête
  cat(cli::col_yellow(header), "\n")
  cat(paste(rep("-", sum(col_widths[names(data)]) + (3 * (ncol(data) - 1))), collapse = ""), "\n")
  
  # Formater et afficher chaque ligne avec des couleurs
  for(i in 1:nrow(data)) {
    row_values <- mapply(function(value, col_name, width) {
      formatted <- format_column(value, width)
      switch(col_name,
             "name" = cli::col_cyan(formatted),
             "symbol" = cli::col_green(formatted),
             "id" = cli::col_magenta(formatted),
             "market_cap" = cli::col_yellow(formatted),
             "twitter_followers" = cli::col_blue(formatted),
             "sentiment_votes_up" = cli::col_green(formatted),
             "sentiment_votes_down" = cli::col_red(formatted),
             formatted)
    }, as.list(data[i,]), names(data), col_widths[names(data)])
    
    cat(paste(row_values, collapse = " | "), "\n")
  }
  cat("\n")
}

# Fonction pour télécharger les 250 premières cryptos
get_top_cryptos <- function() {
  url <- "https://api.coingecko.com/api/v3/coins/markets"
  params <- list(
    vs_currency = "usd",
    order = "market_cap_desc",
    per_page = 250,
    page = 1,
    sparkline = FALSE
  )
  
  response <- GET(url, query = params)
  
  if (status_code(response) == 200) {
    data <- fromJSON(content(response, "text", encoding = "UTF-8"))
    cat(success_style("\nDonnées des 250 premières cryptos téléchargées avec succès !\n\n"))
    return(data)
  } else {
    cat(error_style("\nErreur lors de la récupération des données.\n"))
    return(NULL)
  }
}

# Fonction pour télécharger les données sociales
get_social_data <- function(id) {
  url <- paste0("https://api.coingecko.com/api/v3/coins/", id)
  response <- GET(url)
  
  if (status_code(response) == 200) {
    data <- fromJSON(content(response, "text", encoding = "UTF-8"))
    return(data)
  } else if (status_code(response) == 429) {
    cat(warning_style("\nLimite atteinte pour ", id, ". Pause de 61 secondes...\n"))
    Sys.sleep(61)
    return(NULL)
  } else {
    cat(error_style(paste0("\nErreur lors de la récupération des données pour ", id, "\n")))
    return(NULL)
  }
}

# Menu principal
social_main_menu <- function() {
  repeat {
    cat(section_title_style("\n Options - Social Metrics des Cryptos\n\n"))
    cat(question_style("0) Revenir au menu précédent\n"))
    cat("1) Visualiser les socials metrics sociales d'une crypto spécifique\n")
    cat("2) Visualiser les socials metrics du marché crypto en général\n")
    
    # Lecture et validation de l'entrée utilisateur
    repeat {
      choix <- suppressWarnings(as.integer(readline(question_style("\nVeuillez entrer votre choix (0, 1 ou 2) : "))))
      
      # Vérification si choix est NA ou hors limites
      if (!is.na(choix) && choix >= 0 && choix <= 2) {
        break
      }
      cat(warning_style("\nChoix invalide. Veuillez entrer 0, 1 ou 2 uniquement.\n"))
    }
    
    if (choix == 0) {
      cat(info_style("\nRetour au menu précédent...\n"))
      break
    } else if (choix == 1) {
      visualiser_crypto_specifique()
    } else if (choix == 2) {
      visualiser_cryptos_generales()
    }
  }
}

# Visualisation d'une crypto spécifique
visualiser_crypto_specifique <- function() {
  cat(section_title_style("\nVisualisation des socials metrics d'une crypto spécifique\n"))
  
  repeat {
    connait_id <- tolower(readline(question_style("Connaissez-vous l'ID de la crypto ? (oui/non) : ")))
    if (connait_id %in% c("oui", "non")) break
    cat(warning_style("\nVeuillez répondre uniquement par 'oui' ou 'non'.\n"))
  }
  
  if (connait_id == "oui") {
    repeat {
      id <- readline(question_style("Veuillez entrer l'ID de la crypto : "))
      social_data <- get_social_data(id)
      
      if (!is.null(social_data)) {
        cat(success_style("\nDonnées pour ", id, " téléchargées avec succès !\n\n"))
        
        # Création d'un tableau formaté
        result_df <- data.frame(
          name = social_data$name,
          symbol = social_data$symbol,
          twitter_followers = format_large_number(social_data$community_data$twitter_followers),
          sentiment_votes_up = paste0(round(social_data$sentiment_votes_up_percentage, 2), "%"),
          sentiment_votes_down = paste0(round(social_data$sentiment_votes_down_percentage, 2), "%"),
          stringsAsFactors = FALSE
        )
        
        display_table_fixed_colored2(result_df)
        
        # Analyse du sentiment
        mood_global <- social_data$sentiment_votes_up_percentage
        cat(section_title_style("Analyse du Sentiment :\n\n"))
        cat("Mood Global : ", highlight_style(paste0(round(mood_global, 2), "%\n\n")))
        
        sentiment_message <- if (mood_global > 70) {
          success_style("Le sentiment est hyper positif - Bull Market en vue ! 🚀")
        } else if (mood_global > 50) {
          success_style("Le sentiment est globalement positif 📈")
        } else if (mood_global > 30) {
          warning_style("Le sentiment est globalement négatif 📉")
        } else {
          error_style("Le sentiment est hyper négatif - Bear Market en vue ! 🐻")
        }
        
        cat(sentiment_message, "\n\n")
        break
      } else {
        cat(warning_style("\nID invalide ou problème lors de la récupération. Veuillez réessayer.\n"))
      }
    }
  } else {
    top_cryptos <- get_top_cryptos()
    if (!is.null(top_cryptos)) {
      display_df <- top_cryptos %>% 
        select(name, id, market_cap) %>%
        head(250) %>%
        mutate(market_cap = paste0(format_large_number(round(market_cap / 1e9, 2)), " Mds $"))
      
      cat(section_title_style("\nListe des 250 plus grandes cryptos :\n\n"))
      display_table_fixed_colored2(display_df)
      readline(info_style("Veuillez noter l'ID qui vous intéresse et appuyer sur Entrée pour continuer...\n"))
      visualiser_crypto_specifique()
    }
  }
}

# Visualisation des cryptos en général
visualiser_cryptos_generales <- function() {
  repeat {
    cat(section_title_style("\nVisualisation des sociales metrics des cryptos\n\n"))
    cat(question_style("0) Retour au menu principal\n"))
    cat("1) Visualiser les 4 plus grandes cryptos (", warning_style("Temps d'attente: < 60 secondes"), ")\n")
    cat("2) Visualiser les 8 plus grandes cryptos (", warning_style("temps d'attente estimé : 2 minutes"), ")\n")
    cat("3) Visualiser les 12 plus grandes cryptos (", warning_style("temps d'attente estimé : 3 minutes"), ")\n")
    cat("4) Visualiser les 16 plus grandes cryptos (", warning_style("temps d'attente estimé : 4 minutes"), ")\n")
    cat("5) Choisir un nombre personnalisé de cryptos (", warning_style("Maximum 50"), ")\n")
    
    # Lecture et validation de l'entrée utilisateur
    repeat {
      choix <- suppressWarnings(as.integer(readline(question_style("\nVeuillez entrer votre choix (0-5) : "))))
      
      # Vérification si choix est NA ou hors limites
      if (!is.na(choix) && choix >= 0 && choix <= 5) {
        break
      }
      cat(warning_style("\nChoix invalide. Veuillez entrer un nombre entre 0 et 5.\n"))
    }
    
    if (choix == 0) {
      cat(info_style("\nRetour au menu principal...\n"))
      break
    } else if (choix == 5) {
      # Gestion du nombre personnalisé
      repeat {
        nombre_perso <- suppressWarnings(as.integer(readline(question_style("\nEntrez le nombre de cryptos à visualiser (maximum 50) : "))))
        
        if (!is.na(nombre_perso) && nombre_perso > 0 && nombre_perso <= 50) {
          temps_estime <- ceiling(nombre_perso / 4) * 1.5
          cat(warning_style(paste0("\nTemps d'attente estimé : ", temps_estime, " minutes\n")))
          
          repeat {
            choix_confirme <- tolower(readline(question_style("Voulez-vous continuer ? (oui/non) : ")))
            if (choix_confirme %in% c("oui", "non")) break
            cat(warning_style("\nVeuillez répondre uniquement par 'oui' ou 'non'.\n"))
          }
          
          if (choix_confirme == "oui") {
            top_cryptos <- get_top_cryptos()
            if (!is.null(top_cryptos)) {
              top_ids <- head(top_cryptos$id, nombre_perso)
              afficher_social_metrics(top_ids)
            }
          }
          break
        } else {
          cat(warning_style("\nNombre invalide. Veuillez entrer un nombre entre 1 et 50.\n"))
        }
      }
    } else if (choix >= 1 && choix <= 4) {
      nombre_cryptos <- choix * 4
      top_cryptos <- get_top_cryptos()
      if (!is.null(top_cryptos)) {
        top_ids <- head(top_cryptos$id, nombre_cryptos)
        afficher_social_metrics(top_ids)
      }
    }
  }
}

# Affichage des metrics sociales
afficher_social_metrics <- function(ids) {
  social_data_list <- list()
  sentiment_votes_raw <- numeric()  # Pour stocker les valeurs brutes des sentiments
  
  for (i in seq_along(ids)) {
    id <- ids[i]
    cat(info_style(paste0("\nTéléchargement des données pour : ", id, "...\n")))
    
    social_data <- get_social_data(id)
    
    if (!is.null(social_data)) {
      sentiment_votes_raw <- c(sentiment_votes_raw, social_data$sentiment_votes_up_percentage)
      
      social_data_list[[i]] <- data.frame(
        name = social_data$name,
        symbol = social_data$symbol,
        twitter_followers = format_large_number(social_data$community_data$twitter_followers),
        sentiment_votes_up = paste0(round(social_data$sentiment_votes_up_percentage, 2), "%"),
        sentiment_votes_down = paste0(round(social_data$sentiment_votes_down_percentage, 2), "%"),
        stringsAsFactors = FALSE
      )
    }
    
    if (i %% 4 == 0 && i < length(ids)) {
      cat(warning_style("\nPause de 61 secondes pour respecter les limites de l'API...\n"))
      Sys.sleep(61)
    } else {
      Sys.sleep(2)
    }
  }
  
  cat("\nRésultats :\n\n")
  social_data_table <- do.call(rbind, social_data_list)
  display_table_fixed_colored2(social_data_table)
  
  # Calcul et affichage du sentiment global
  mood_global <- mean(sentiment_votes_raw)
  cat(section_title_style("Analyse du Sentiment Global :\n\n"))
  cat("Mood Global : ", highlight_style(paste0(round(mood_global, 2), "%\n\n")))
  
  # Analyse du sentiment
  sentiment_message <- if (mood_global > 70) {
    success_style("Le sentiment est hyper positif - Bull Market en vue ! 🚀")
  } else if (mood_global > 50) {
    success_style("Le sentiment est globalement positif 📈")
  } else if (mood_global > 30) {
    warning_style("Le sentiment est globalement négatif 📉")
  } else {
    error_style("Le sentiment est hyper négatif - Bear Market en vue ! 🐻")
  }
  
  cat(sentiment_message, "\n\n")
}

# Exécution du menu principal

###############################################################################@
######## TREND ANALYSIS
################################################################################

# Fonction améliorée pour formater les grands nombres
format_large_number <- function(x) {
  sapply(x, function(value) {
    if (is.na(value)) {
      "N/A"
    } else {
      format(value, big.mark = " ", scientific = FALSE)
    }
  })
}

display_table_fixed_colored_generique <- function(data, title = NULL) {
  data <- as.data.frame(lapply(data, function(x) {
    ifelse(is.na(x), "N/A", x)
  }))
  
  col_widths <- c(
    rank = 5,
    name = 40,
    symbol = 10,
    score = 10,
    market_cap_rank = 15,
    price_change = 15,
    market_cap = 20
  )
  
  format_column <- function(values, width) {
    sapply(values, function(x) {
      x <- substr(as.character(x), 1, width)
      sprintf(paste0("%-", width, "s"), x)
    })
  }
  
  if (!is.null(title)) {
    cat(section_title_style(paste0("\n", title, "\n\n")))
  }
  
  header_parts <- mapply(function(name, width) {
    if (is.na(width)) {
      toupper(name)
    } else {
      sprintf(paste0("%-", width, "s"), toupper(name))
    }
  }, names(data), col_widths[names(data)])
  
  header <- paste(header_parts, collapse = " | ")
  cat(cli::col_yellow(header), "\n")
  cat(paste(rep("-", nchar(header)), collapse = ""), "\n")
  
  for (i in 1:nrow(data)) {
    row_values <- mapply(function(value, col_name, width) {
      formatted <- format_column(value, width)
      switch(col_name,
             "name" = cli::col_cyan(formatted),
             "symbol" = cli::col_green(formatted),
             "score" = cli::col_yellow(formatted),
             "market_cap_rank" = cli::col_magenta(formatted),
             "price_change" = {
               if (value == "N/A") {
                 formatted
               } else {
                 value <- as.numeric(gsub("%", "", value))
                 if (value >= 0) cli::col_green(formatted) else cli::col_red(formatted)
               }
             },
             formatted)
    }, as.list(data[i,]), names(data), col_widths[names(data)])
    
    cat(paste(row_values, collapse = " | "), "\n")
  }
  cat("\n")
}

##################
display_table_fixed_colored_option4 <- function(data, title = NULL) {
  data <- as.data.frame(lapply(data, function(x) as.character(x)))
  data[is.na(data)] <- "N/A"
  
  col_widths <- c(
    name = 40,
    market_cap = 20,
    change_24h = 15
  )
  
  format_column <- function(values, width) {
    sapply(values, function(x) {
      x <- substr(as.character(x), 1, width)
      sprintf(paste0("%-", width, "s"), x)
    })
  }
  
  if (!is.null(title)) {
    cat(section_title_style(paste0("\n", title, "\n\n")))
  }
  
  header_parts <- mapply(function(name, width) {
    sprintf(paste0("%-", width, "s"), toupper(name))
  }, names(data), col_widths[names(data)])
  
  header <- paste(header_parts, collapse = " | ")
  cat(cli::col_yellow(header), "\n")
  cat(paste(rep("-", nchar(header)), collapse = ""), "\n")
  
  for (i in 1:nrow(data)) {
    row_values <- mapply(function(value, col_name, width) {
      formatted <- format_column(value, width)
      switch(col_name,
             "name" = cli::col_cyan(formatted),
             "market_cap" = cli::col_green(formatted),
             "change_24h" = {
               value <- as.numeric(gsub("%", "", value))
               if (is.na(value)) cli::col_yellow(formatted)
               else if (value >= 0) cli::col_green(formatted) else cli::col_red(formatted)
             },
             formatted)
    }, as.list(data[i,]), names(data), col_widths[names(data)])
    
    cat(paste(row_values, collapse = " | "), "\n")
  }
  cat("\n")
}

# Fonction pour récupérer les tendances
get_trends <- function() {
  tryCatch({
    response <- GET("https://api.coingecko.com/api/v3/search/trending")
    
    if (status_code(response) == 200) {
      data <- fromJSON(rawToChar(response$content))
      return(data)
    } else {
      cat(error_style("\nErreur lors de la récupération des tendances. Code:", status_code(response), "\n"))
      return(NULL)
    }
  }, error = function(e) {
    cat(error_style("\nErreur de connexion à l'API:", e$message, "\n"))
    return(NULL)
  })
}

# Fonction pour obtenir les informations d'une crypto spécifique
get_coin_info <- function(id) {
  tryCatch({
    response <- GET(paste0("https://api.coingecko.com/api/v3/coins/", id))
    
    if (status_code(response) == 200) {
      data <- fromJSON(rawToChar(response$content))
      return(data)
    } else {
      cat(error_style("\nErreur lors de la récupération des informations. Code:", status_code(response), "\n"))
      return(NULL)
    }
  }, error = function(e) {
    cat(error_style("\nErreur de connexion à l'API:", e$message, "\n"))
    return(NULL)
  })
}

# Fonction pour obtenir les catégories
get_categories <- function() {
  tryCatch({
    response <- GET("https://api.coingecko.com/api/v3/coins/categories")
    
    if (status_code(response) == 200) {
      data <- fromJSON(rawToChar(response$content))
      return(data)
    } else {
      cat(error_style("\nErreur lors de la récupération des catégories. Code:", status_code(response), "\n"))
      return(NULL)
    }
  }, error = function(e) {
    cat(error_style("\nErreur de connexion à l'API:", e$message, "\n"))
    return(NULL)
  })
}

#######################################
# Fonction pour l'analyse des tendances (Option 1)
analyze_trends <- function() {
  cat(section_title_style("\n=== Analyse des Tendances de Recherche ===\n\n"))
  
  # Texte explicatif
  cat(info_style("Cette section vous présente les cryptomonnaies et NFTs actuellement en tendance sur CoinGecko.\n\n"))
  cat(info_style("Les données affichées sont basées sur :\n"))
  cat(info_style("- Le volume de recherches effectuées par les utilisateurs sur CoinGecko.\n"))
  cat(info_style("- Les interactions des utilisateurs sur des plateformes sociales comme Twitter et Reddit.\n\n"))
  cat(info_style("Ces tendances sont calculées sur une période récente (souvent quelques jours à une semaine)\n"))
  cat(info_style("et sont mises à jour régulièrement pour refléter les changements d'intérêt des utilisateurs.\n\n"))
  cat(success_style("Vous trouverez ci-dessous les actifs les plus populaires, classés par recherche et intérêt :\n\n"))
  
  trends_data <- get_trends()
  if (!is.null(trends_data)) {
    # Cryptos en tendance
    crypto_trends <- data.frame(
      name = trends_data$coins$item$name,
      symbol = toupper(trends_data$coins$item$symbol)
    )
    
    cat(success_style("\nTop Cryptos les plus recherchées :\n"))
    display_table_fixed_colored_generique(head(crypto_trends, 100))
    
    # NFTs en tendance
    nft_trends <- data.frame(
      name = trends_data$nfts$name,
      symbol = toupper(trends_data$nfts$symbol)
    )
    
    cat(success_style("\nTop NFTs les plus recherchés :\n"))
    display_table_fixed_colored_generique(head(nft_trends, 50))
  }
  
  readline(question_style("\nAppuyez sur Entrée pour revenir au menu..."))
}

#####################################
# Fonction pour le score de tendance (Option 2)
trend_score_analysis <- function() {
  cat(section_title_style("\n=== Score de Tendance ===\n\n"))
  
  # Explication du score de tendance
  cat(highlight_style("Le score de tendance reflète l'intérêt des utilisateurs envers une cryptomonnaie.\n\n"))
  cat(info_style("Ce score est basé sur :\n"))
  cat(info_style("- Le volume de recherches et d'interactions sur CoinGecko.\n"))
  cat(info_style("- Les mentions et interactions sur des plateformes sociales comme Twitter et Reddit.\n\n"))
  cat(info_style("La période d'analyse couvre environ 30 jours. Les données sont mises à jour\n"))
  cat(info_style("régulièrement pour refléter les tendances actuelles.\n\n"))
  cat(info_style("Contrairement aux variations de prix ou à la capitalisation, ce score mesure\n"))
  cat(info_style("l'intérêt global et non financier envers une cryptomonnaie donnée.\n\n"))
  
  # Lecture du score
  cat(success_style("Lecture du score :\n"))
  cat(info_style("- Un score élevé (par exemple, 15-20) indique une forte popularité récente.\n"))
  cat(info_style("- Un score de 0 signifie un intérêt très faible ou inexistant.\n"))
  cat(info_style("- La plage des scores observés varie généralement entre 0 et environ 15-20,\n"))
  cat(info_style("  mais elle n'a pas de limite fixe supérieure.\n\n"))
  
  cat(success_style("Les cryptos les plus populaires du moment sont affichées ci-dessous :\n\n"))
  
  trends_data <- get_trends()
  if (!is.null(trends_data)) {
    # Construction des données pour le tableau
    trend_scores <- data.frame(
      name = trends_data$coins$item$name,
      symbol = toupper(trends_data$coins$item$symbol),
      market_cap_rank = trends_data$coins$item$market_cap_rank,
      score = trends_data$coins$item$score
    )
    
    # Tri des cryptos par score décroissant
    trend_scores <- trend_scores %>%
      arrange(desc(score))
    
    # Augmentation de la limite d'affichage (affiche tout ce qui est disponible)
    cat(success_style("Classement par popularité :\n"))
    display_table_fixed_colored_generique(head(trend_scores, 100))
  } else {
    cat(error_style("\nImpossible de récupérer les tendances actuellement. Veuillez réessayer plus tard.\n"))
  }
  
  readline(question_style("\nAppuyez sur Entrée pour revenir au menu..."))
}


####################################################
# Fonction pour afficher les cryptos disponibles
show_available_coins <- function() {
  cat(section_title_style("\nListe des Cryptos Disponibles\n"))
  
  # Faire la requête pour obtenir la liste des cryptos
  tryCatch({
    response <- GET("https://api.coingecko.com/api/v3/coins/list")
    
    if (status_code(response) == 200) {
      coins <- fromJSON(rawToChar(response$content))
      
      # Création du dataframe pour l'affichage
      coins_df <- data.frame(
        name = coins$name,
        symbol = toupper(coins$symbol),
        id = coins$id
      )
      
      # Affichage paginé (20 par page)
      total_pages <- ceiling(nrow(coins_df) / 20)
      page <- 1
      
      repeat {
        # Afficher la page courante
        start_idx <- ((page - 1) * 20) + 1
        end_idx <- min(page * 20, nrow(coins_df))
        current_page <- coins_df[start_idx:end_idx, ]
        
        cat(section_title_style(sprintf("\nPage %d/%d\n\n", page, total_pages)))
        display_table_fixed_colored_generique(current_page)
        
        # Options de navigation
        cat(question_style("\nOptions :\n"))
        cat("1) Page suivante\n")
        cat("2) Page précédente\n")
        cat("3) Aller à une page spécifique\n")
        cat("4) Rechercher par nom\n")
        cat("0) Retour au menu précédent\n")
        
        choix <- suppressWarnings(as.integer(readline(question_style("\nVotre choix : "))))
        
        if (is.na(choix)) next
        
        if (choix == 0) break
        
        switch(choix,
               "1" = {
                 if (page < total_pages) page <- page + 1
                 else cat(warning_style("\nVous êtes déjà à la dernière page.\n"))
               },
               "2" = {
                 if (page > 1) page <- page - 1
                 else cat(warning_style("\nVous êtes déjà à la première page.\n"))
               },
               "3" = {
                 new_page <- suppressWarnings(as.integer(readline(question_style(
                   sprintf("\nEntrez le numéro de page (1-%d) : ", total_pages)))))
                 if (!is.na(new_page) && new_page >= 1 && new_page <= total_pages) {
                   page <- new_page
                 } else {
                   cat(warning_style("\nNuméro de page invalide.\n"))
                 }
               },
               "4" = {
                 search_term <- tolower(readline(question_style("\nEntrez le terme à rechercher : ")))
                 found_coins <- coins_df[grep(search_term, tolower(coins_df$name)), ]
                 
                 if (nrow(found_coins) > 0) {
                   cat(success_style("\nRésultats de la recherche :\n"))
                   display_table_fixed_colored_generique(head(found_coins, 20))
                   readline(question_style("\nAppuyez sur Entrée pour continuer..."))
                 } else {
                   cat(warning_style("\nAucune crypto trouvée avec ce terme.\n"))
                 }
               })
      }
      
    } else {
      cat(error_style("\nErreur lors de la récupération de la liste. Code:", status_code(response), "\n"))
    }
  }, error = function(e) {
    cat(error_style("\nErreur de connexion à l'API:", e$message, "\n"))
  })
}

# Fonction pour afficher les informations détaillées d'une crypto
display_coin_info <- function(coin_data) {
  cat(section_title_style(paste("\nInformations détaillées pour", coin_data$name, "\n")))
  
  # Informations de base
  cat(success_style("\n=== Informations de Base ===\n"))
  cat(info_style("Nom: "), coin_data$name, "\n")
  cat(info_style("Symbole: "), toupper(coin_data$symbol), "\n")
  cat(info_style("Rang Market Cap: "), coin_data$market_cap_rank, "\n")
  
  # Prix et variations
  cat(success_style("\n=== Prix et Variations ===\n"))
  if (!is.null(coin_data$market_data)) {
    cat(info_style("Prix actuel (USD): $"), format(coin_data$market_data$current_price$usd, scientific = FALSE), "\n")
    cat(info_style("Variation 24h: "), 
        ifelse(coin_data$market_data$price_change_percentage_24h >= 0,
               success_style(paste0("+", round(coin_data$market_data$price_change_percentage_24h, 2), "%")),
               warning_style(paste0(round(coin_data$market_data$price_change_percentage_24h, 2), "%"))), "\n")
  }
  
  # Capitalisation
  if (!is.null(coin_data$market_data$market_cap)) {
    cat(success_style("\n=== Capitalisation ===\n"))
    cat(info_style("Market Cap (USD): $"), format_large_number(coin_data$market_data$market_cap$usd), "\n")
    cat(info_style("Volume 24h (USD): $"), format_large_number(coin_data$market_data$total_volume$usd), "\n")
  }
  
  # Données sociales
  if (!is.null(coin_data$community_data)) {
    cat(success_style("\n=== Métriques Sociales ===\n"))
    cat(info_style("Twitter Followers: "), format_large_number(coin_data$community_data$twitter_followers), "\n")
    if (!is.null(coin_data$community_data$reddit_subscribers)) {
      cat(info_style("Reddit Subscribers: "), format_large_number(coin_data$community_data$reddit_subscribers), "\n")
    }
  }
  
  # Description
  if (!is.null(coin_data$description$en)) {
    cat(success_style("\n=== Description ===\n"))
    cat(info_style(coin_data$description$en), "\n")
  }
  
  readline(question_style("\nAppuyez sur Entrée pour continuer..."))
}

##########################################################
# Fonction pour les informations sur les projets (Option 3)
project_information <- function() {
  cat(section_title_style("\n=== Informations sur les Projets ===\n\n"))
  
  # Texte introductif
  cat(highlight_style("Cette section vous permet d'explorer des informations détaillées sur les projets des cryptomonnaies disponibles.\n\n"))
  cat(info_style("Vous pouvez :\n"))
  cat(info_style("- Rechercher des détails sur les projets d'une cryptomonnaie spécifique en entrant son ID ou son nom.\n"))
  cat(info_style("- Explorer les 15 projets les plus populaires et en tendance actuellement.\n"))
  cat(info_style("- Parcourir les cryptos disponibles dans des catégories spécifiques comme DeFi, NFT, Gaming, etc.\n\n"))
  cat(success_style("Les données affichées incluent les noms, symboles, prix, variations, rangs de capitalisation et bien plus encore !\n\n"))
  
  
  repeat {
    cat(section_title_style("\n=== Informations sur les Projets ===\n\n"))
    cat(question_style("1) Rechercher une crypto spécifique\n"))
    cat("2) Voir le top 15 des projets en tendance\n")
    cat("3) Rechercher par catégorie\n")
    cat(question_style("0) Retour au menu principal\n"))
    
    choix <- suppressWarnings(as.integer(readline(question_style("\nVotre choix (0-3) : "))))
    
    if (is.na(choix) || choix < 0 || choix > 3) {
      cat(warning_style("\nChoix invalide. Veuillez réessayer.\n"))
      next
    }
    
    if (choix == 0) break
    
    switch(choix,
           "1" = search_specific_crypto(),
           "2" = show_top_15_projects(),
           "3" = search_by_category())
  }
}

# Sous-fonctions pour l'option 3
search_specific_crypto <- function() {
  repeat {
    cat(section_title_style("\nRecherche d'une Crypto Spécifique\n"))
    connait_id <- tolower(readline(question_style("\nConnaissez-vous l'ID de la crypto ? (oui/non) : ")))
    
    if (connait_id %in% c("oui", "non")) {
      if (connait_id == "oui") {
        id <- readline(question_style("Entrez l'ID de la crypto : "))
        coin_data <- get_coin_info(id)
        
        if (!is.null(coin_data)) {
          display_coin_info(coin_data)
        }
      } else {
        show_available_coins()
      }
      break
    }
    
    cat(warning_style("\nVeuillez répondre par 'oui' ou 'non'.\n"))
  }
}

##############
show_top_15_projects <- function() {
  cat(section_title_style("\n=== Top 15 Projets en Tendance ===\n\n"))
  
  # Texte explicatif
  cat(highlight_style("Ce classement reflète les cryptomonnaies actuellement en tendance sur CoinGecko.\n\n"))
  cat(info_style("Les tendances sont calculées en fonction de :\n"))
  cat(info_style("- Le volume de recherches des utilisateurs sur CoinGecko.\n"))
  cat(info_style("- Les interactions sur des plateformes sociales comme Twitter et Reddit.\n"))
  cat(info_style("- L'engagement global des utilisateurs (listes de favoris, consultations fréquentes).\n\n"))
  cat(info_style("Ce classement est dynamique et se concentre sur l'intérêt récent, souvent sur les 7 derniers jours.\n"))
  cat(info_style("Les cryptomonnaies affichées peuvent inclure des projets émergents ou moins connus,\n"))
  cat(info_style("attirant soudainement l'attention des utilisateurs.\n\n"))
  cat(success_style("Vous trouverez ci-dessous les 15 projets les plus populaires actuellement :\n\n"))
  
  # Récupération des tendances
  trends_data <- get_trends()
  if (!is.null(trends_data)) {
    # Construction du tableau avec des informations supplémentaires
    trending_projects <- data.frame(
      name = trends_data$coins$item$name,
      symbol = toupper(trends_data$coins$item$symbol),
      market_cap_rank = trends_data$coins$item$market_cap_rank,
      url = paste0("https://www.coingecko.com/en/coins/", trends_data$coins$item$id) # Génération de l'URL
    )
    
    # Affichage des résultats
    for (i in 1:min(15, nrow(trending_projects))) {
      project <- trending_projects[i, ]
      cat(success_style(paste0("\n", i, ". ", project$name, " (", project$symbol, ")\n")))
      cat(info_style("   Rang Market Cap : ", project$market_cap_rank, "\n"))
      cat(info_style("   URL du Projet : ", project$url, "\n"))
      
      # Appel de l'API pour récupérer les détails du projet avec gestion des erreurs
      details <- tryCatch({
        get_coin_info(trends_data$coins$item$id[i])
      }, error = function(e) {
        NULL
      })
      
      if (!is.null(details)) {
        # Extraction de la capitalisation boursière
        market_cap_billion <- ifelse(!is.null(details$market_data$market_cap$usd), 
                                     details$market_data$market_cap$usd / 1e9, NA)
        
        # Formatage des nombres
        formatted_market_cap <- ifelse(!is.na(market_cap_billion), 
                                       paste0(format(round(market_cap_billion, 2), big.mark = " "), " Mds $"), 
                                       "N/A")
        
        # Affichage des données supplémentaires
        cat(info_style("   Capitalisation : ", formatted_market_cap, "\n"))
      } else {
        cat(warning_style("   Impossible de récupérer les détails supplémentaires.\n"))
      }
      
      # Pause de 1 seconde entre les requêtes pour limiter le débit
      Sys.sleep(1)
    }
  } else {
    cat(warning_style("\nAucune donnée disponible pour les projets en tendance.\n"))
  }
}


#########################

search_by_category <- function() {
  categories <- get_categories()
  if (!is.null(categories)) {
    cat(section_title_style("\nCatégories Disponibles\n\n"))
    
    for (i in 1:length(categories$name)) {
      cat(sprintf("%d) %s\n", i, categories$name[i]))
    }
    
    cat(question_style("\n0) Retour\n"))
    
    choix <- suppressWarnings(as.integer(readline(question_style("\nChoisissez une catégorie (0-", length(categories$name), ") : "))))
    
    if (!is.na(choix) && choix > 0 && choix <= length(categories$name)) {
      show_category_projects(categories$id[choix])
    }
  }
}

# Fonction pour afficher les projets d'une catégorie
show_category_projects <- function(category_id) {
  tryCatch({
    url <- paste0("https://api.coingecko.com/api/v3/coins/markets")
    params <- list(
      vs_currency = "usd",
      category = category_id,
      order = "market_cap_desc",
      per_page = 50,
      page = 1,
      sparkline = FALSE
    )
    
    response <- GET(url, query = params)
    
    if (status_code(response) == 200) {
      data <- fromJSON(rawToChar(response$content))
      
      if (length(data) > 0) {
        projects_df <- data.frame(
          name = data$name,
          symbol = toupper(data$symbol),
          market_cap = format_large_number(data$market_cap),
          price_change = paste0(round(data$price_change_percentage_24h, 2), "%")
        )
        
        cat(section_title_style(paste("\nProjets dans la catégorie :", category_id, "\n")))
        display_table_fixed_colored_generique(projects_df)
        
        # Options pour voir plus de détails
        repeat {
          cat(question_style("\nOptions :\n"))
          cat("1) Voir les détails d'un projet\n")
          cat("0) Retour\n")
          
          choix <- suppressWarnings(as.integer(readline(question_style("\nVotre choix (0-1) : "))))
          
          if (is.na(choix) || choix < 0 || choix > 1) {
            cat(warning_style("\nChoix invalide.\n"))
            next
          }
          
          if (choix == 0) break
          
          if (choix == 1) {
            project_id <- readline(question_style("\nEntrez l'ID du projet à consulter : "))
            coin_data <- get_coin_info(project_id)
            if (!is.null(coin_data)) {
              display_coin_info(coin_data)
            }
          }
        }
      } else {
        cat(warning_style("\nAucun projet trouvé dans cette catégorie.\n"))
      }
    } else {
      cat(error_style("\nErreur lors de la récupération des projets. Code:", status_code(response), "\n"))
    }
  }, error = function(e) {
    cat(error_style("\nErreur lors de la récupération des projets:", e$message, "\n"))
  })
}

#################################################################
## Fonction pour l'analyse des catégories (Option 4)
category_analysis <- function() {
  cat(section_title_style("\n=== Analyse des Catégories et Secteurs ===\n\n"))
  cat(highlight_style("Cette section explore les dynamiques des différentes catégories de cryptomonnaies.\n\n"))
  cat(info_style("Les catégories regroupent les projets selon leur utilité, écosystème ou secteur d'activité.\n"))
  cat(info_style("Les données affichées incluent :\n"))
  cat(info_style("- Le nom de chaque catégorie.\n"))
  cat(info_style("- La capitalisation de marché totale (en milliards de dollars).\n"))
  cat(info_style("- La variation de capitalisation sur 24 heures, exprimée en pourcentage.\n\n"))
  cat(info_style("Ces informations sont utiles pour :\n"))
  cat(info_style("- Repérer les secteurs en forte croissance ou en déclin.\n"))
  cat(info_style("- Comprendre les tendances générales du marché crypto.\n"))
  cat(info_style("- Découvrir de nouvelles niches et opportunités d'investissement.\n\n"))
  cat(success_style("Les catégories les plus importantes et leurs variations sur 24 heures sont affichées ci-dessous :\n"))
  
  categories <- get_categories()
  if (!is.null(categories)) {
    # Vue d'ensemble économique
    cat(success_style("\nVue d'ensemble des catégories :\n"))
    
    # Construction du tableau avec gestion des valeurs NA
    summary_df <- data.frame(
      name = ifelse(is.na(categories$name), "N/A", categories$name),
      market_cap = ifelse(is.na(categories$market_cap), 
                          "N/A", 
                          paste0(format(round(as.numeric(categories$market_cap) / 1e9, 2), big.mark = " "), " Mds $")),
      change_24h = ifelse(is.na(categories$market_cap_change_24h), "N/A", paste0(round(categories$market_cap_change_24h, 2), "%"))
    )
    
    # Limiter l'affichage aux 20 premières catégories
    summary_df <- head(summary_df, 20)
    
    # Affichage du tableau
    display_table_fixed_colored_option4(summary_df, "Résumé des Catégories")
    
    # Catégories en croissance/déclin
    top_growing <- head(arrange(summary_df, desc(as.numeric(gsub("%", "", change_24h)))), 10)
    top_declining <- head(arrange(summary_df, as.numeric(gsub("%", "", change_24h))), 10)
    
    cat(success_style("\nTop 10 Catégories en Croissance :\n"))
    display_table_fixed_colored_option4(top_growing)
    
    cat(warning_style("\nTop 10 Catégories en Déclin :\n"))
    display_table_fixed_colored_option4(top_declining)
  } else {
    cat(warning_style("\nAucune donnée disponible pour les catégories.\n"))
  }
  
  readline(question_style("\nAppuyez sur Entrée pour revenir au menu..."))
}


# Fonction pour l'analyse des variations horaires (Option 5)
hot_hour_analysis <- function() {
  cat(section_title_style("\n=== Hot Hour Analysis ===\n\n"))
  cat(highlight_style("Cette section met en évidence les plus fortes variations de prix des cryptomonnaies\n"))
  cat(info_style("et des NFTs sur une période récente (24 heures).\n\n"))
  cat(info_style("Les données incluent :\n"))
  cat(info_style("- Les cryptomonnaies avec les plus fortes hausses ou baisses de prix.\n"))
  cat(info_style("- Les NFTs avec les variations de prix planchers les plus significatives.\n\n"))
  cat(info_style("Utilité de cette analyse :\n"))
  cat(info_style("- Identifier les projets les plus volatils et dynamiques du moment.\n"))
  cat(info_style("- Repérer des opportunités d'investissement ou des points d'entrée sur le marché.\n"))
  cat(info_style("- Suivre les tendances du marché en temps réel.\n\n"))
  cat(success_style("Les cryptomonnaies et NFTs les plus dynamiques des dernières 24 heures sont affichés ci-dessous :\n\n"))
  
  
  trends_data <- get_trends()
  if (!is.null(trends_data)) {
    # Cryptos
    crypto_changes <- data.frame(
      name = trends_data$coins$item$name,
      symbol = toupper(trends_data$coins$item$symbol),
      price_change = sapply(trends_data$coins$item$data$price_change_percentage_24h$usd, function(x) {
        if (is.null(x) || is.na(x)) {
          "N/A"
        } else {
          paste0(round(as.numeric(x), 2), "%")
        }
      })
    )
    
    # Top 50 hausses
    cat(success_style("\n Top Hausses Cryptos (24h) :\n"))
    valid_changes <- crypto_changes[crypto_changes$price_change != "N/A", ]
    if (nrow(valid_changes) > 0) {
      top_gainers <- head(arrange(valid_changes, desc(as.numeric(gsub("%", "", price_change)))), 50)
      display_table_fixed_colored_generique(top_gainers)
    } else {
      cat(warning_style("Aucune donnée de variation disponible.\n"))
    }
    
    # Top 50 baisses
    cat(warning_style("\nTop Baisses Cryptos (24h) :\n"))
    if (nrow(valid_changes) > 0) {
      top_losers <- head(arrange(valid_changes, as.numeric(gsub("%", "", price_change))), 50)
      display_table_fixed_colored_generique(top_losers)
    } else {
      cat(warning_style("Aucune donnée de variation disponible.\n"))
    }
    
    # NFTs
    if (length(trends_data$nfts) > 0) {
      nft_changes <- data.frame(
        name = trends_data$nfts$name,
        symbol = toupper(trends_data$nfts$symbol),
        price_change = sapply(trends_data$nfts$floor_price_24h_percentage_change, function(x) {
          if (is.null(x) || is.na(x)) {
            "N/A"
          } else {
            paste0(round(as.numeric(x), 2), "%")
          }
        })
      )
      
      valid_nft_changes <- nft_changes[nft_changes$price_change != "N/A", ]
      
      # Top 10 NFT hausses
      cat(success_style("\nTop NFTs en Hausse :\n"))
      if (nrow(valid_nft_changes) > 0) {
        top_nft_gainers <- head(arrange(valid_nft_changes, desc(as.numeric(gsub("%", "", price_change)))), 10)
        display_table_fixed_colored_generique(top_nft_gainers)
      } else {
        cat(warning_style("Aucune donnée de variation disponible.\n"))
      }
      
      # Top 10 NFT baisses
      cat(warning_style("\nTop NFTs en Baisse :\n"))
      if (nrow(valid_nft_changes) > 0) {
        top_nft_losers <- head(arrange(valid_nft_changes, as.numeric(gsub("%", "", price_change))), 10)
        display_table_fixed_colored_generique(top_nft_losers)
      } else {
        cat(warning_style("Aucune donnée de variation disponible.\n"))
      }
    }
  }
  
  readline(question_style("\nAppuyez sur Entrée pour revenir au menu..."))
}


# Menu 
################################

trend_menu <- function() {
  repeat {
    # Message d'introduction
    cat(section_title_style("\n=== Analyse des Tendances du Marché Crypto ===\n"))
    cat(info_style("\nBienvenue dans l'analyseur de tendances. Cet outil vous permet d'explorer\n"))
    cat(info_style("les tendances actuelles du marché des cryptomonnaies et des NFTs.\n"))
    
    # Options du menu
    cat(section_title_style("\nOptions Disponibles :\n\n"))
    cat(question_style("0) Retour au menu Pépite\n"))
    cat("1) Analyse des tendances (Top Cryptos et Top NFTs)\n")
    cat("2) Score de tendance et popularité\n")
    cat("3) Information détaillée sur les projets\n")
    cat("4) Analyse des catégories et secteurs\n")
    cat("5) Hot Hour (Variations horaires)\n")
    
    # Lecture et validation du choix
    repeat {
      choix <- suppressWarnings(as.integer(readline(question_style("\nVeuillez entrer votre choix (0-5) : "))))
      
      if (!is.na(choix) && choix >= 0 && choix <= 5) {
        break
      }
      cat(warning_style("\nChoix invalide. Veuillez entrer un nombre entre 0 et 5.\n"))
    }
    
    # Traitement du choix
    if (choix == 0) {
      cat(info_style("\nRetour au menu Pépite...\n"))
      break
    }
    
    # Exécution de la fonction correspondante
    switch(choix,
           "1" = analyze_trends(),
           "2" = trend_score_analysis(),
           "3" = project_information(),
           "4" = category_analysis(),
           "5" = hot_hour_analysis())
  }
}

# Exécution du menu principal des tendances




################################################################################
#########                  LUNAR CRUSH (API Payante)
################################################################################

lunar_crush <- function() {
  # Message d'introduction
  cat(section_title_style("\nBienvenue sur LunarCrush - Analyse Crypto avancée !\n"))
  cat(success_style("\n===========================================================\n"))
  cat(highlight_style("LunarCrush est une plateforme innovante qui fournit des analyses approfondies sur les cryptomonnaies. Voici ce qu'elle offre :\n"))
  
  cat(highlight_style("\nAnalyse des tendances sociales :"), 
      info_style("Découvrez les cryptomonnaies les plus mentionnées sur les réseaux sociaux, identifiez les tendances émergentes et évaluez l'intérêt communautaire."), "\n")
  
  cat(highlight_style("\nAnalyse des tendances de recherche :"), 
      info_style("Obtenez un aperçu des recherches les plus populaires pour les cryptos sur diverses plateformes."), "\n")
  
  cat(highlight_style("\nAltRank :"), 
      info_style("Classement unique qui combine l'activité sociale et les indicateurs de marché pour évaluer les opportunités cachées."), "\n")
  
  cat(highlight_style("\nGalaxy Score :"), 
      info_style("Un score exclusif basé sur une combinaison de données sociales, de marché et techniques pour mesurer la santé et la qualité d'une crypto."), "\n")
  
  cat(success_style("\n===========================================================\n"))
  
  # Message indiquant que l'outil est en pause
  cat(warning_style("\nActuellement, notre outil est en cours de développement car l'API LunarCrush nécessite un abonnement payant.\n"))
  cat(warning_style("\nLa construction de cet outil est donc temporairement en pause.\n"))
  
  # Menu principal pour LunarCrush
  repeat {
    cat(section_title_style("\n=== Menu LunarCrush ===\n"))
    options <- c(
      question_style("Retour au menu PépitesHunter"),
      "Analyse des tendances sociales",
      "Analyse des tendances de recherche",
      "AltRank",
      "Galaxy Score"
    )
    
    for (i in seq_along(options)) {
      cat(paste0(i - 1, ". ", options[i], "\n"))
    }
    
    choix <- readline(question_style("Veuillez choisir une option (par numéro) : "))
    
    if (choix == "0") {
      cat(question_style("\nRetour au menu PépitesHunter...
"))
      break
    } else if (choix %in% c("1", "2", "3", "4")) {
      option <- options[as.numeric(choix) + 1]
      cat(success_style(paste0("\nVous avez choisi : ", option, "\n")))
      
      # Explication spécifique à chaque option
      if (option == "Analyse des tendances sociales") {
        cat(info_style("\nL'analyse des tendances sociales vous permet de repérer les cryptomonnaies les plus mentionnées sur les réseaux sociaux. Ces informations peuvent aider à identifier des opportunités avant qu'elles ne deviennent mainstream.\n"))
      } else if (option == "Analyse des tendances de recherche") {
        cat(info_style("\nCette option analyse les termes de recherche pour les cryptos, ce qui peut indiquer un intérêt croissant ou une tendance en développement.\n"))
      } else if (option == "AltRank") {
        cat(info_style("\nAltRank combine l'activité sociale et les indicateurs de marché pour classer les cryptos, en mettant en lumière celles qui ont un potentiel caché.\n"))
      } else if (option == "Galaxy Score") {
        cat(info_style("\nGalaxy Score est un indicateur unique qui évalue la santé globale et la qualité d'une crypto en fonction de données sociales, de marché et techniques.\n"))
      }
      
      # Message indiquant que la fonctionnalité est indisponible
      cat(warning_style("\nCette fonctionnalité est en cours de construction.\n"))
      cat(warning_style("\nMalheureusement, l'API LunarCrush est payante et nécessite un abonnement.\n"))
    } else {
      cat(warning_style("\nChoix invalide. Veuillez sélectionner un numéro parmi les options disponibles.\n"))
    }
  }
}

# Appel à la fonction principale



################################################################################
#########                  Santiment (API Payante)
################################################################################

santiment <- function() {
  # Message d'introduction
  cat(section_title_style("\nBienvenue sur Santiment - Analyse Crypto avancée !\n"))
  cat(success_style("\n===========================================================\n"))
  cat(highlight_style("Santiment est une plateforme spécialisée dans l'analyse des cryptomonnaies, axée sur quatre types de données principales :\n"))
  
  cat(highlight_style("\nDonnées on-chain :"), 
      info_style("Cela inclut les transactions en temps réel, les flux d'échanges, et les données blockchain pertinentes. Ces analyses permettent d'identifier les mouvements de \"whales\" (grands détenteurs de crypto) ou des changements inhabituels dans les activités on-chain."), "\n")
  
  cat(highlight_style("\nSignaux sociaux :"), 
      info_style("Analyse des discussions sur les réseaux sociaux pour détecter les tendances émergentes et les sentiments autour des cryptomonnaies."), "\n")
  
  cat(highlight_style("\nAnalyse de sentiment de marché :"), 
      info_style("Utilise des métriques pour comprendre si le sentiment global des investisseurs est optimiste, pessimiste ou neutre."), "\n")
  
  cat(highlight_style("\nDonnées de développement :"), 
      info_style("Données sur l'activité des développeurs des projets blockchain, incluant les commits GitHub ou l'évolution des projets techniques."), "\n")
  
  cat(success_style("\n===========================================================\n"))
  
  # Message indiquant que l'outil est en pause
  cat(warning_style("\nActuellement, cet outil est en cours de développement car l'API Santiment nécessite un abonnement payant.\n"))
  cat(warning_style("\nLa construction de cet outil est donc temporairement en pause.\n"))
  
  # Menu principal pour Santiment
  repeat {
    cat(section_title_style("\n=== Menu Santiment ===\n"))
    options <- c(
      question_style("Retour au menu PépitesHunter"),
      "Analyse des données on-chain",
      "Analyse des signaux sociaux",
      "Analyse du sentiment de marché",
      "Suivi des données de développement"
    )
    
    for (i in seq_along(options)) {
      cat(paste0(i - 1, ". ", options[i], "\n"))
    }
    
    choix <- readline(info_style("Veuillez choisir une option (par numéro) : "))
    
    if (choix == "0") {
      cat(question_style("\nRetour au menu PépitesHunter...
"))
      break
    } else if (choix %in% c("1", "2", "3", "4")) {
      option <- options[as.numeric(choix) + 1]
      cat(success_style(paste0("\nVous avez choisi : ", option, "\n")))
      
      # Message indiquant que la fonctionnalité est indisponible
      cat(warning_style("\nCette fonctionnalité est en cours de construction.\n"))
      cat(warning_style("\nMalheureusement, l'API Santiment est payante et nécessite un abonnement.\n"))
    } else {
      cat(warning_style("\nChoix invalide. Veuillez sélectionner un numéro parmi les options disponibles.\n"))
    }
  }
}

# Appel à la fonction principale

##################################################
# Appel à la fonction PépitesHunter
##################################################


pepite_hunter <- function() {
  cat(section_title_style("\nPépitesHunter - Cryptowise Copilote :\n"))
  cat(success_style("\n===========================================================\n"))
  cat(highlight_style("Bienvenue sur votre outil unique pour détecter les signaux de probable run sur des cryptomonnaies prometteuses.\n"))
  cat(info_secondary_style("\nAvec PépitesHunter, vous pouvez :\n"))
  cat("- Analyser les cryptos les plus recherchées sur différentes plateformes.\n")
  cat("- Observer leur progression sur plusieurs périodes temporelles.\n")
  cat("- Identifier les mouvements potentiels avant qu'ils ne deviennent des tendances majeures.\n")
  cat(info_secondary_style("\n Nos options:\n"))
  cat("- ", highlight_style("Signal Prix"), ": Observer en temps réel les variations de prix des cryptos et détecter les signaux de rupture.\n")
  cat("- ", highlight_style("Volume et Trading"), ": Analyser les volumes de trading pour identifier les cryptos les plus liquides.\n")
  cat("- ", highlight_style("Statistiques Sociales"), ": Explorer les métriques sociales pour mesurer l’engagement et les opinions.\n")
  cat("- ", highlight_style("Analyse des Tendances et Recherches Populaires"), ": Découvrir les cryptos en vogue grâce à des analyses des tendances actuelles.\n")
  cat("- ", highlight_style("Google Trend"), ": Suivre les recherches Google pour identifier les cryptos qui suscitent le plus d’intérêt.\n")
  cat("- ", highlight_style("Lunar Crush"), ": Plonger dans les insights sociaux détaillés des cryptomonnaies.\n")
  cat("- ", highlight_style("Santiment"), ": Étudier les données on-chain et le sentiment global du marché crypto.\n")
  
  cat(success_style("===========================================================\n"))
  
  # Télécharger les données une fois au début
  download_coingecko_data()
  
  # Vérifier si les données ont été correctement téléchargées
  if (is.null(coingecko_data) || nrow(coingecko_data) == 0) {
    cat(error_style("\nImpossible de continuer : les données n'ont pas été téléchargées correctement.\n"))
    return()
  }
  
  
  repeat {
    cat(section_title_style("\n=== Menu des outils PépitesHunter ===\n"))
    cat(question_style("0) Retour au menu principal\n"))
    cat("1) Signal Prix\n")
    cat("2) Volume et Trading\n")
    cat("3) Statistiques Sociales\n")
    cat("4) Analyse des Tendances et Recherches Populaires\n")
    cat("5) Google Trend\n")
    cat("6) Lunar Crush (", warning_style("restreinte"), ")\n")
    cat("7) Santiment (", warning_style("restreinte"), ")\n")
    
    
    choix <- readline(question_style("\nVotre choix : "))
    
    if (choix == "0") {
      cat(info_style("\nRetour au menu principal...\n"))
      break
    } else if (choix == "1") {
      process_price_signals(coingecko_data)
    } else if (choix == "2") {
      process_volume_trading(coingecko_data)
    } else if (choix == "3") {
      social_main_menu()
    } else if (choix == "4") {
      trend_menu()
    } else if (choix == "5") {
      cat(warning_style("\nGoogle Trend est en cours de développement.\n"))
    } else if (choix == "6") {
      lunar_crush()
    } else if (choix == "7") {
      santiment()
    } else {
      cat(warning_style("\nOption invalide. Veuillez réessayer.\n"))
    }
  }
}


# Appel à la fonction PépitesHunter
pepite_hunter()

